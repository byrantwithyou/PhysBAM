#!/usr/bin/python
import sys
import re
import physbam
import os
import math
section_re=re.compile("\[(.+)\]")
parent_child_re=re.compile("\s*(\S+)\s*(\S+)\s*")
whitespace_re=re.compile("\s+")

axes=[physbam.Vf3(1,0,0),physbam.Vf3(0,1,0),physbam.Vf3(0,0,1)]

if len(sys.argv)!=2 and len(sys.argv)!=3:
    print "Usage: %s input.htr [output.mtn]"%sys.argv[0]
    sys.exit(1)

htr_name=sys.argv[1]
if len(sys.argv)==2:
    motion_name=re.sub('.htr','.mtn',htr_name)
    print "WARNING: ouput.mtn is not specified, guessing %s"%motion_name
else:
    motion_name=sys.argv[2]

class HTR_PARSER:
    def __init__(self,htr_name,motion_name):
        self.joints={}
        self.offsets={}
        self.rotations={}
        self.data={}
        self.name_to_track_index={}

        self.frame_count=None
        self.frame_rate=None
        self.num_bones=None
        self.order=[]
        self.axes_order=[]
        self.names=[]
        self.motion_data=physbam.BODY_MOTION_SEQUENCE_f();

        self.angle_conversion=1.
        self.unit_conversion=1e-3

        self.i=0
        
        self.parse(htr_name)

    def hierarchySection(self,line):
        m=parent_child_re.match(line)
        if m:
            child,parent=m.group(1),m.group(2)
            if not self.joints.has_key(parent):
                self.joints[parent]=[]
            self.joints[parent].append(child)
            if not self.joints.has_key(child): self.joints[child]=[]
    
    def basePosition(self,line):
        guys=whitespace_re.split(line)
        joint=guys[0]
        self.i+=1
        self.names.append(joint)
        self.motion_data.names[self.i]=joint
        data=map(lambda x: self.unit_conversion*float(x),guys[1:4])
        self.offsets[joint]=[data[self.axes_order[0]],data[self.axes_order[1]],data[self.axes_order[2]]]
        data=map(float,guys[4:7])
        self.rotations[joint]=[data[self.axes_order[0]],data[self.axes_order[1]],data[self.axes_order[2]]]
        self.data[joint]=[]
        bone=physbam.BONE_f();
        bone.length=self.unit_conversion*float(guys[7])
        self.motion_data.base_position[self.i]=bone
    
    def dataLine(self,joint,line):
        guys=whitespace_re.split(line)
        data=map(lambda x: self.unit_conversion*float(x),guys[1:4])+map(float,guys[4:7])
        self.data[joint].append([data[self.axes_order[0]],data[self.axes_order[1]],data[self.axes_order[2]],
                                data[3+self.axes_order[0]],data[3+self.axes_order[1]],data[3+self.axes_order[2]]]) 
        bone=physbam.BONE_f()
        bone.length=self.unit_conversion*float(guys[7])
        self.motion_data.trajectories[self.name_to_track_index[joint]][physbam.Vi1(int(guys[0]))]=bone
        self.motion_data.valid[self.name_to_track_index[joint]][physbam.Vi1(int(guys[0]))]=True
    
    def header(self,line):
        guys=whitespace_re.split(line)
        if guys[0]=="EulerRotationOrder":
            for axes_char in guys[1]:
                if axes_char=="X": self.order.append(0)
                if axes_char=="Y": self.order.append(1)
                if axes_char=="Z": self.order.append(2)
                #axes.reverse()
        if guys[0]=="NumFrames":
            self.frame_count=int(guys[1])
        if guys[0]=="NumSegments":
            self.num_bones=int(guys[1])
        if guys[0]=="DataFrameRate":
            self.frame_rate=int(guys[1])
        if guys[0]=="RotationUnits" and guys[1]=="Degrees":
            self.angle_conversion=math.pi/180.;
        if guys[0]=="CalibrationUnits":
            if guys[1]=="m":
                self.unit_conversion=1
            elif guys[1]=="cm":
                self.unit_conversion=1e-2
            elif guys[1]=="mm":
                self.unit_conversion=1e-3
        if guys[0]=="GlobalAxisofGravity":
            if guys[1]=="Y": 
                self.axes_order.append(0)
                self.axes_order.append(1)
                self.axes_order.append(2)
            if guys[1]=="Z":
                self.axes_order.append(1)
                self.axes_order.append(2)
                self.axes_order.append(0)
            if guys[1]=="X":
                self.axes_order.append(2)
                self.axes_order.append(0)
                self.axes_order.append(1)
        if guys[0]=="BoneLengthAxis":
            mult=1;
            if guys[0][0]=="-":
                mult=-1
                guys[0][0]=guys[0][1]
            if guys[0][0]=="X": self.motion_data.bone_axis=mult*axes[0]
            if guys[0][0]=="Y": self.motion_data.bone_axis=mult*axes[1]
            if guys[0][0]=="Z": self.motion_data.bone_axis=mult*axes[2]

    def parse(self,filename):
         section=None
         fp=open(filename)
         first=True

         while 1:
             line=fp.readline()
             if line=="": break
             # new section
             if line.startswith("#"): continue
             m=section_re.match(line)
             if m:
                 section=m.group(1)
                 # We just finished the header
                 if section=="SegmentNames&Hierarchy":
                    time_grid=physbam.GRID_Vf1(self.frame_count,1,1)
                    self.motion_data.Initialize(self.num_bones,time_grid)
                    self.motion_data.Set_Frame_Rate(self.frame_rate,0.)
             # something else
             else:
                 if section=="SegmentNames&Hierarchy":
                     self.hierarchySection(line)
                 elif section=="Header":
                     self.header(line)
                 elif section=="BasePosition":
                     self.basePosition(line)
                 elif self.joints.has_key(section):
                     if(first):
                         for i in range(len(self.names)):
                             name=self.names[i]
                             self.name_to_track_index[name]=i+1
                             for child in self.joints[name]:
                                 self.motion_data.bone_hierarchy[i+1].Append(child)
                         first=False
                     self.dataLine(section,line)

    def Base_Rotation(self,joint):
        return physbam.FRAME_Vf3(physbam.Vf3(),physbam.ROTATION_Vf3(self.rotations[joint][self.order[0]]*self.angle_conversion,axes[self.order[0]]))\
                                *physbam.FRAME_Vf3(physbam.Vf3(),physbam.ROTATION_Vf3(self.rotations[joint][self.order[1]]*self.angle_conversion,axes[self.order[1]]))\
                                *physbam.FRAME_Vf3(physbam.Vf3(),physbam.ROTATION_Vf3(self.rotations[joint][self.order[2]]*self.angle_conversion,axes[self.order[2]]))

    def Rotation(self,frame,joint):
        d=self.data[joint][frame]
        return physbam.FRAME_Vf3(physbam.Vf3(),physbam.ROTATION_Vf3(d[self.order[1]+3]*self.angle_conversion,axes[self.order[1]]))\
                    *physbam.FRAME_Vf3(physbam.Vf3(),physbam.ROTATION_Vf3(d[self.order[2]+3]*self.angle_conversion,axes[self.order[2]]))\
                    *physbam.FRAME_Vf3(physbam.Vf3(),physbam.ROTATION_Vf3(d[self.order[0]+3]*self.angle_conversion,axes[self.order[0]]))
    def Translation(self,frame,joint):
        d=self.data[joint][frame]
        F=physbam.FRAME_Vf3(physbam.Vf3(d[0],d[1],d[2]))
        return F

motion=HTR_PARSER(htr_name,motion_name)

def Make_Transform(level,frame,parent_transform,parent,joint):
    global axes

    transform=parent_transform
    if joint!="GLOBAL":
        #previous_and_translation=parent_transform*physbam.FRAME_Vf3(physbam.Vf3(*motion.offsets[joint]))
        previous_and_translation=parent_transform*motion.Translation(frame,joint)
        if joint=="Root":
            previous_and_translation=previous_and_translation*motion.Translation(0,joint).Inverse()
            
        transform=previous_and_translation*motion.Rotation(frame,joint)

        #motion.motion_data.trajectories[motion.name_to_track_index[joint]][physbam.Vi1(frame+1)].transform=motion.Rotation(frame,joint)
        #motion.motion_data.trajectories[motion.name_to_track_index[joint]][physbam.Vi1(frame+1)].targeted_transform=transform
        motion.motion_data.Set_Targeted(motion.name_to_track_index[joint],frame+1,transform);
        motion.motion_data.Set_Transform(motion.name_to_track_index[joint],frame+1,transform);

    for kid in motion.joints[joint]:
        if frame is 0: 
            print joint+" has kid "+kid;
        Make_Transform(level+1,frame,transform,joint,kid)
    
for frame in xrange(motion.frame_count):
    Make_Transform(0,frame,physbam.FRAME_Vf3(),"None","GLOBAL")

physbam.Write_To_File("float",motion_name,motion.motion_data)
