//#####################################################################
// Copyright 2012, Craig Schroeder, Alexey Stomakhin.
// This file is part of PhysBAM whose distribution is governed by the license contained in the accompanying file PHYSBAM_COPYRIGHT.txt.
//#####################################################################
#include <Tools/Grids_Uniform/CELL_ITERATOR.h>
#include <Tools/Grids_Uniform/GRID.h>
#include <Tools/Grids_Uniform_Arrays/ARRAYS_ND.h>
#include <Geometry/Basic_Geometry/SEGMENT_2D.h>
#include <Geometry/Basic_Geometry/TRIANGLE_3D.h>
#include <Geometry/Grids_Uniform_Computations/MARCHING_TETRAHEDRA.h>
#include <Geometry/Topology_Based_Geometry/SEGMENTED_CURVE_2D.h>
#include <Geometry/Topology_Based_Geometry/TRIANGULATED_SURFACE.h>
using namespace PhysBAM;
template<> int MARCHING_TETRAHEDRA_CASE<2>::vertex_lookup[3][2]={{0,1},{0,2},{1,2}};
template<> int MARCHING_TETRAHEDRA_CASE<3>::vertex_lookup[6][2]={{0,1},{0,2},{0,3},{1,2},{1,3},{2,3}};

// 2d: 0-2 = vectex, 3=01 4=02 5=12
static const MARCHING_TETRAHEDRA_CASE<2> case_table2[8] = 
{
    {{0x00},{{{0x12},{0x00}},{{0x20},{0x00}},{{0x01},{0x00}}}}, // 0
    {{0x34},{{{0x12},{0x00}},{{0x24},{0x40}},{{0x31},{0x03}}}}, // 1
    {{0x53},{{{0x52},{0x15}},{{0x20},{0x00}},{{0x03},{0x31}}}}, // 2
    {{0x54},{{{0x52},{0x15}},{{0x24},{0x40}},{{0x00},{0x01}}}}, // 3
    {{0x45},{{{0x15},{0x52}},{{0x40},{0x24}},{{0x01},{0x00}}}}, // 4
    {{0x35},{{{0x15},{0x52}},{{0x00},{0x20}},{{0x31},{0x03}}}}, // 5
    {{0x43},{{{0x00},{0x12}},{{0x40},{0x24}},{{0x03},{0x31}}}}, // 6
    {{0x00},{{{0x00},{0x12}},{{0x00},{0x20}},{{0x00},{0x01}}}}  // 7
};
// 3d: 0-3 = vectex, 4=01 5=02 6=03 7=12 8=13 9=23
static const MARCHING_TETRAHEDRA_CASE<3> case_table3[16] = 
{
    {{0x000,0x000},{{{0x321,0x000},{0x000,0x000}},{{0x302,0x000},{0x000,0x000}},{{0x310,0x000},{0x000,0x000}},{{0x201,0x000},{0x000,0x000}}}}, // 0
    {{0x654,0x000},{{{0x321,0x000},{0x000,0x000}},{{0x352,0x365},{0x056,0x000}},{{0x314,0x346},{0x406,0x000}},{{0x241,0x254},{0x504,0x000}}}}, // 1
    {{0x847,0x000},{{{0x327,0x378},{0x718,0x000}},{{0x302,0x000},{0x000,0x000}},{{0x340,0x384},{0x148,0x000}},{{0x072,0x047},{0x417,0x000}}}}, // 2
    {{0x857,0x865},{{{0x327,0x378},{0x718,0x000}},{{0x352,0x365},{0x056,0x000}},{{0x386,0x000},{0x081,0x068}},{{0x725,0x000},{0x150,0x175}}}}, // 3
    {{0x975,0x000},{{{0x371,0x397},{0x279,0x000}},{{0x305,0x359},{0x529,0x000}},{{0x310,0x000},{0x000,0x000}},{{0x150,0x175},{0x725,0x000}}}}, // 4
    {{0x769,0x746},{{{0x139,0x197},{0x927,0x000}},{{0x936,0x000},{0x260,0x296}},{{0x163,0x146},{0x064,0x000}},{{0x174,0x000},{0x072,0x047}}}}, // 5
    {{0x498,0x459},{{{0x839,0x000},{0x192,0x189}},{{0x093,0x059},{0x295,0x000}},{{0x038,0x084},{0x814,0x000}},{{0x045,0x000},{0x241,0x254}}}}, // 6
    {{0x698,0x000},{{{0x839,0x000},{0x192,0x189}},{{0x936,0x000},{0x029,0x096}},{{0x386,0x000},{0x081,0x068}},{{0x000,0x000},{0x012,0x000}}}}, // 7
    {{0x689,0x000},{{{0x192,0x189},{0x839,0x000}},{{0x029,0x096},{0x936,0x000}},{{0x081,0x068},{0x386,0x000}},{{0x012,0x000},{0x000,0x000}}}}, // 8
    {{0x489,0x495},{{{0x192,0x189},{0x839,0x000}},{{0x295,0x000},{0x093,0x059}},{{0x814,0x000},{0x038,0x084}},{{0x241,0x254},{0x045,0x000}}}}, // 9
    {{0x764,0x796},{{{0x279,0x000},{0x371,0x397}},{{0x260,0x296},{0x369,0x000}},{{0x406,0x000},{0x163,0x146}},{{0x204,0x247},{0x417,0x000}}}}, // 10
    {{0x957,0x000},{{{0x279,0x000},{0x371,0x397}},{{0x529,0x000},{0x305,0x359}},{{0x000,0x000},{0x310,0x000}},{{0x725,0x000},{0x150,0x175}}}}, // 11
    {{0x875,0x856},{{{0x718,0x000},{0x327,0x378}},{{0x056,0x000},{0x352,0x365}},{{0x081,0x068},{0x386,0x000}},{{0x150,0x175},{0x725,0x000}}}}, // 12
    {{0x874,0x000},{{{0x718,0x000},{0x327,0x378}},{{0x000,0x000},{0x302,0x000}},{{0x148,0x000},{0x340,0x384}},{{0x417,0x000},{0x072,0x047}}}}, // 13
    {{0x645,0x000},{{{0x000,0x000},{0x321,0x000}},{{0x056,0x000},{0x352,0x365}},{{0x406,0x000},{0x314,0x346}},{{0x504,0x000},{0x241,0x254}}}}, // 14
    {{0x000,0x000},{{{0x000,0x000},{0x321,0x000}},{{0x000,0x000},{0x302,0x000}},{{0x000,0x000},{0x310,0x000}},{{0x000,0x000},{0x201,0x000}}}}  // 15
};
const MARCHING_TETRAHEDRA_CASE<2>* Case_Table_Helper(VECTOR<int,2>*) {return case_table2;}
const MARCHING_TETRAHEDRA_CASE<3>* Case_Table_Helper(VECTOR<int,3>*) {return case_table3;}
//#####################################################################
// Function Case_Table
//#####################################################################
template<class TV> const MARCHING_TETRAHEDRA_CASE<TV::m>* MARCHING_TETRAHEDRA<TV>::
Case_Table()
{
    return Case_Table_Helper((TV_INT*)0);
}
//#####################################################################
// Function Get_Triangles_For_Tetrahedron
//#####################################################################
template<class TV> void MARCHING_TETRAHEDRA<TV>::
Get_Elements_For_Tetrahedron(ARRAY<T_FACE>& surface,const VECTOR<VECTOR<ARRAY<T_FACE>*,2>,TV::m+1>& boundary,const VECTOR<T,TV::m+1>& phi,const VECTOR<TV,TV::m+1>& X)
{
    TV pts[num_pts];
    const MARCHING_TETRAHEDRA_CASE<TV::m>* table=Case_Table();

    int c=0;
    for(int i=0;i<phi.m;i++){
        pts[i]=X(i);
        c|=(phi(i)<0)<<i;}

    for(int i=0;i<num_edges;i++){
        int v0=MARCHING_TETRAHEDRA_CASE<TV::m>::vertex_lookup[i][0];
        int v1=MARCHING_TETRAHEDRA_CASE<TV::m>::vertex_lookup[i][1];
        if(((c>>v0)^(c>>v1))&1){
            T t=phi(v0)/(phi(v0)-phi(v1));
            pts[i+num_corners]=pts[v0]+t*(pts[v1]-pts[v0]);}}

    const MARCHING_TETRAHEDRA_CASE<TV::m>& cs=table[c];

    Fill_Faces(surface,cs.surface,pts);
    for(int i=0;i<TV::m+1;i++)
        for(int j=0;j<2;j++)
            if(boundary(i)(j))
                Fill_Faces(*boundary(i)(j),cs.boundary[i][j],pts);
}
//#####################################################################
// Function Get_Triangles_For_Tetrahedron
//#####################################################################
template<class TV> void MARCHING_TETRAHEDRA<TV>::
Fill_Faces(ARRAY<T_FACE>& faces,const unsigned short* face_encoding,const TV* pts)
{
    int len=(TV::m==3?2:1);
    for(int i=0;i<len && face_encoding[i];i++){
        T_FACE face;
        for(int j=0;j<TV::m;j++)
            face.X(j)=pts[(face_encoding[i]>>4*j)&15];
        faces.Append(face);}
}
namespace PhysBAM{
template class MARCHING_TETRAHEDRA<VECTOR<float,2> >;
template class MARCHING_TETRAHEDRA<VECTOR<float,3> >;
template class MARCHING_TETRAHEDRA<VECTOR<double,2> >;
template class MARCHING_TETRAHEDRA<VECTOR<double,3> >;
}
