//#####################################################################
// Copyright 2011, Jeffrey Hellrung.
// This file is part of PhysBAM whose distribution is governed by the
// license contained in the accompanying file PHYSBAM_COPYRIGHT.txt.
//#####################################################################
// TODO: Replace BASE_QUADRATURE_RULE_ORDER with a Boost.MPL
// metafunction that gives the quadrature rule.
//#####################################################################

#ifndef PHYSBAM_PUBLIC_LIBRARY_JEFFREY_UTILITIES_GEOMETRY_INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR_HPP
#define PHYSBAM_PUBLIC_LIBRARY_JEFFREY_UTILITIES_GEOMETRY_INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR_HPP

#include <boost/mpl/always.hpp>
#include <boost/type_traits/integral_constant.hpp>

#include <Jeffrey_Utilities/Geometry/INTEGRATE_MULTI_POWERS_POLYTOPE_VISITOR.h>
#include <Jeffrey_Utilities/Geometry/POLYTOPE_LOCAL_INTEGRATE_FLUX_FUNCTION_TIMES_MONOMIAL_OVER_BOUNDARY.h>

namespace PhysBAM
{

template< int BASE_QUADRATURE_RULE_ORDER, class T_F, class T_RESULT_OF_MULTI_POWER >
struct INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR_TRAITS
{
    typedef INTEGRATE_MULTI_POWERS_POLYTOPE_VISITOR<
        1,
        boost::mpl::always< boost::true_type >,
        POLYTOPE_LOCAL_INTEGRATE_FLUX_FUNCTION_TIMES_MONOMIAL_OVER_BOUNDARY< BASE_QUADRATURE_RULE_ORDER, T_F >,
        T_RESULT_OF_MULTI_POWER
    > INTEGRATE_MULTI_POWERS_POLYTOPE_VISITOR_;
};

template< int BASE_QUADRATURE_RULE_ORDER, class T_F, class T_RESULT_OF_MULTI_POWER >
class INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR
    : public INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR_TRAITS<
          BASE_QUADRATURE_RULE_ORDER, T_F, T_RESULT_OF_MULTI_POWER
      >::INTEGRATE_MULTI_POWERS_POLYTOPE_VISITOR_
{
    typedef INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR_TRAITS<
        BASE_QUADRATURE_RULE_ORDER, T_F, T_RESULT_OF_MULTI_POWER
    > INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR_TRAITS_;
    typedef typename INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR_TRAITS_::
        INTEGRATE_MULTI_POWERS_POLYTOPE_VISITOR_ INTEGRATE_MULTI_POWERS_POLYTOPE_VISITOR_;
public:
    INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR(
        const int sign,
        const T_F& f,
        const T_RESULT_OF_MULTI_POWER& result_of_multi_power)
        : INTEGRATE_MULTI_POWERS_POLYTOPE_VISITOR_(
              sign,
              POLYTOPE_LOCAL_INTEGRATE_FLUX_FUNCTION_TIMES_MONOMIAL_OVER_BOUNDARY<
                  BASE_QUADRATURE_RULE_ORDER, T_F
              >(f),
              result_of_multi_power
          )
    { }
};

template< int BASE_QUADRATURE_RULE_ORDER, class T_F, class T_RESULT_OF_MULTI_POWER >
inline INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR<
    BASE_QUADRATURE_RULE_ORDER, T_F, T_RESULT_OF_MULTI_POWER
>
Make_Integrate_Flux_Function_Times_Multi_Powers_Over_Boundary_For_Poisson_Polytope_Visitor(
    const int sign,
    const T_F& f,
    const T_RESULT_OF_MULTI_POWER result_of_multi_power)
{
    return INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR<
        BASE_QUADRATURE_RULE_ORDER, T_F, T_RESULT_OF_MULTI_POWER
    >(sign, f, result_of_multi_power);
}

} // namespace PhysBAM

#endif // #ifndef PHYSBAM_PUBLIC_LIBRARY_JEFFREY_UTILITIES_GEOMETRY_INTEGRATE_FLUX_FUNCTION_TIMES_MULTI_POWERS_OVER_BOUNDARY_FOR_POISSON_POLYTOPE_VISITOR_HPP
